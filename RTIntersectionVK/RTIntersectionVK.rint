#version 460
#extension GL_EXT_ray_tracing : enable

struct AttrNT
{
    vec3 Normal;
    vec2 Texcoord;
};
hitAttributeEXT AttrNT Attr;

bool Sphere(const vec3 Center, const float Radius, out float t)
{
	//!< レイのパラメータ表現 Ray = o + d * t ただし o = gl_ObjectRayOriginEXT, d = gl_ObjectRayDirectionEXT
    //!< (Ray - Center)^2 = Radius^2
    //!< (d * t + Tmp0)^2 = Radius^2 ただし Tmp0 = (o - Center)
    //!< d^2 * t^2 + 2 * Tmp0 * d * t + Tmp0^2 - Radius^2 = 0
    //!< A * t^2 + B * t + C = 0 ただし A = d^2, B = 2 * Tmp0 * d, C = Tmp0^2 - Radius^2
    //!< 判別式 D = B * B - 4.0f * A * C
    //!< 判別式 D4 = B2 * B2 - A * C ただし B2 = B / 2
    //!< 解の公式 t = (-B +- sqrt(D)) / 2 * A
    //!< 解の公式 t = (-B2 +- sqrt(D4)) / A
    
    const vec3 Tmp0 = gl_ObjectRayOriginEXT - Center;
    const vec3 d = gl_ObjectRayDirectionEXT;

    const float A = dot(d, d);
    const float B2 = dot(Tmp0, d);
    const float C = dot(Tmp0, Tmp0) - Radius * Radius;
    const float D4 = B2 * B2 - A * C;

	if(D4 >= 0.0f) {
        const float Sq = sqrt(D4);
        const float Tmp1 = (-B2 - Sq) / A;
        const float Tmp2 = (-B2 + Sq) / A;
        const float t0 = min(Tmp1, Tmp2);
        t = (t0 >= gl_RayTminEXT && t0 <= gl_RayTmaxEXT) ? t0 : max(Tmp1, Tmp2);
        if(t >= gl_RayTminEXT && t <= gl_RayTmaxEXT) {
            return true;
        }
	}
    return false;
}

bool AABB(const vec3 Center, const vec3 Radius, out float t)
{
    //!< レイのパラメータ表現 Ray = o + d * t ただし o = ObjectRayOrigin(), d = ObjectRayDirection()
    //!< Ray = Plane[+-X+-Y+-Z] ... レイに 6 平面を代入
    //!< o + d * t = Plane[+-X+-Y+-Z]
    //!< t = (Plane[+-X+-Y+-Z] - o) / d
    
    const vec3 AABBMin = Center - Radius;
    const vec3 AABBMax = Center + Radius;

    const vec3 invd = 1.0f / gl_ObjectRayDirectionEXT;
    const vec3 Tmp0 = (AABBMin - gl_ObjectRayOriginEXT) * invd;
    const vec3 Tmp1 = (AABBMax - gl_ObjectRayOriginEXT) * invd;
    const vec3 tMin = min(Tmp0, Tmp1);
    const vec3 tMax = max(Tmp0, Tmp1);
    const float t0 = max(max(tMin.x, tMin.y), tMin.z);
    const float t1 = min(min(tMax.x, tMax.y), tMax.z);
    if (t0 <= t1) {
        t = t0 < gl_RayTminEXT ? t1 : t0;
        if (t >= gl_RayTminEXT && t <= gl_RayTmaxEXT) {
            return true;
        }
    }
    return false;
}

//!< ペイロードへ書き込みはできない、アトリビュートを生成して他シェーダへ供給
void main()
{
#if 0
   const vec3 Center = vec3(0.0f);
   const vec3 Radius = vec3(0.5f);
   float t;
   if(AABB(Center, Radius, t)) {
        const vec3 Hit = gl_ObjectRayOriginEXT + gl_ObjectRayDirectionEXT * t;
        const vec3 N = normalize(Hit - Center);
        const vec3 NAbs = abs(N);
        const float MaxComp = max(max(NAbs.x, NAbs.y), NAbs.z);
        if (MaxComp == NAbs.x) {
            Attr.Normal = vec3(sign(N.x), 0.0f, 0.0f);
        }
        else if (MaxComp == NAbs.y) {
            Attr.Normal = vec3(0.0f, sign(N.x), 0.0f);
        }
        else {
            Attr.Normal = vec3(0.0f, 0.0f, sign(N.x));
        }

        //Attr.Texcoord

        const uint Kind = 0; //!< ここでは使用しないので 0
        reportIntersectionEXT(t, Kind);
    }
#else    
    const vec3 Center = vec3(0.0f);
	const float Radius = 0.5f;
    float t;
    if(Sphere(Center, Radius, t)) {
        const vec3 Hit = gl_ObjectRayOriginEXT + gl_ObjectRayDirectionEXT * t;
        Attr.Normal = normalize(Hit - Center);

        const float PI = 4.0f * atan(1.0f);
        const float PI2 = PI * 2.0f;
        Attr.Texcoord = vec2(fract(atan(Attr.Normal.y, Attr.Normal.x) / PI2), acos(-Attr.Normal.z) / PI);

        const uint Kind = 0; //!< ここでは使用しないので 0
        reportIntersectionEXT(t, Kind);
    }
#endif
}